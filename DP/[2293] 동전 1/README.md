# [2293] 동전 1
## 💡Algorithm
- DP
## 📚Logic
- 첫 번째 동전만 사용해서 각 k값 마다 가능한 경우의 수를 찾는다.
- 첫 번째 ~ n번 째 동전을 사용했을때까지 반복한다.
```c++
dp[0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = 1; j <= k; j++) {
            if (j >= coin[i]) dp[j] += dp[j - coin[i]];
        }
    }
```
## 📝Review
Top-Down 방식으로 5분도 안되서 구현했지만, 이 문제는 Bottom-Up 방식으로 풀게 되어있다.

도저히 구현을 어떻게 할지 몰라서 결국 구글에 찾아봤다. 코드를 봐도 이해가 잘 안된다. 열심히 공부하자...
